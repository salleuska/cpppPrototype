% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/runCalibration.R
\name{runCalibration}
\alias{runCalibration}
\title{Run posterior predictive calibration}
\usage{
runCalibration(
  MCMCSamples,
  observedData,
  MCMCFun,
  simulateNewDataFun,
  discFun,
  nReps,
  drawIndexSelector = NULL,
  control = list(),
  ...
)
}
\arguments{
\item{MCMCSamples}{Matrix of posterior draws from the observed-data fit.
Each row corresponds to one posterior draw of the model parameters.}

\item{observedData}{Observed dataset. This dataset is treated
as the conditioning data for the initial discrepancy calculation.}

\item{MCMCFun}{Function defined as
\verb{function(targetData, control)} that runs an MCMC algorithm conditional on
\code{targetData} and returns posterior samples as a matrix.}

\item{simulateNewDataFun}{Function defined as
\verb{function(thetaRow, control)} that simulates one replicated dataset
from the posterior predictive distribution given a single posterior
draw \code{thetaRow}.}

\item{discFun}{Discrepancy extractor with signature
\verb{function(MCMCSamples, targetData, control)} returning a list with
components \code{obs} and \code{sim}, each a numeric vector (one value per row of
\code{MCMCSamples}).

In typical use, \code{discFun} is created by one of the package helpers:
\describe{
\item{\code{makeOfflineDiscFun()}}{Computes discrepancies by evaluating a
user-specified discrepancy \eqn{D(data, \theta)} on \code{targetData} and on
posterior predictive replicates simulated for each posterior draw.}
\item{\code{makeColDiscFun()}}{Extracts precomputed discrepancy columns
from \code{MCMCSamples} (online mode), returning them as \code{obs} and \code{sim}.}
}

Custom \code{discFun} functions are also supported, as long as the return value
has named components \code{obs} and \code{sim} of equal length.}

\item{nReps}{Integer. Number of calibration replicates.}

\item{drawIndexSelector}{Optional function
\verb{function(MCMCSamples, nReps, control)} returning a vector of row indices
selecting which posterior draws are used as seeds for calibration worlds.
If \code{NULL}, indices are chosen evenly over the posterior sample.}

\item{control}{Optional list of arguments passed to components used by
\code{runCalibration()}.

For convenience, \code{control} may be a flat list, in which case it is passed
unchanged to all components.

Alternatively, \code{control} may be a structured list with named sublists:
\describe{
\item{mcmc}{Arguments passed to \code{MCMCFun}, typically controlling short
MCMC runs in replicated calibration worlds (e.g., \code{niter}, \code{nburnin}).}
\item{disc}{Arguments passed to \code{simulateNewDataFun} and \code{discFun},
typically including model objects, data node names, or parameter names.}
\item{draw}{Arguments passed to \code{drawIndexSelector}, if provided.}
\item{parallel}{Optional list controlling parallel execution of
replicated calibration worlds. Supported fields:
\describe{
\item{workers}{Integer number of PSOCK workers. Default is 1 (serial).}
\item{seed}{Optional integer seed for reproducible parallel RNG.}
\item{export}{Optional character vector of object names (e.g. helper functions) to export to workers.}
\item{packages}{Optional character vector of packages to load on workers.}
}}
}}

\item{...}{Not used currently.}
}
\value{
An object of class \code{cpppResult} containing:
\describe{
\item{CPPP}{Calibrated posterior predictive p-value.}
\item{obsPPP}{Posterior predictive p-value for the observed data.}
\item{repPPP}{Vector of posterior predictive p-values for each
calibration world.}
\item{discrepancies}{List containing observed and replicated discrepancies.}
\item{drawnIndices}{Indices of posterior draws used as calibration seeds.}
}
}
\description{
Computes a calibrated posterior predictive p-value (CPPP) using
posterior predictive checks and replicated calibration worlds.
}
\details{
The function is backend-agnostic: model fitting, data simulation,
and discrepancy evaluation are provided by user-supplied functions.

Calibration replicates are conditionally independent given the
posterior sample and may be executed in parallel using PSOCK clusters.
Objects referenced by \code{MCMCFun}, \code{discFun}, and \code{simulateNewDataFun} must
be serializable and available on worker processes.
}
